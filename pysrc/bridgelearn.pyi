from typing import Dict, List, Optional

import torch

import bridge

GameParameters = Dict[str, str]
TensorDict = Dict[str, torch.Tensor]


class BridgeData:
    deal: List[int]
    ddt: List[int]


class BridgeDataset:
    def __init__(self, deals: List[List[int]], ddts: Optional[List[List[int]]]):
        ...

    def next(self) -> BridgeData: ...

    def size(self) -> int: ...


class BridgeEnv:
    def __init__(self, params: GameParameters, verbose: bool): ...

    def parameters(self) -> GameParameters: ...

    def feature_size(self) -> int: ...

    def set_bridge_dataset(self, bridge_dataset: BridgeDataset): ...

    def reset_with_bridge_data(self): ...

    def reset(self): ...

    def reset_with_deck(self, deal: List[int]): ...

    def reset_with_deck_and_double_dummy_results(self, deal: List[int], double_dummy_results: List[int]): ...

    def step(self, move: Optional[bridge.BridgeMove, int]): ...

    def terminated(self) -> bool: ...

    def returns(self) -> List[int]: ...

    def current_player(self) -> int: ...

    def ble_state(self) -> bridge.BridgeState: ...

    def ble_game(self) -> bridge.BridgeGame: ...

    def ble_observation(self) -> bridge.BridgeObservation: ...

    def get_move(self, uid: int) -> bridge.BridgeMove: ...

    def last_active_player(self) -> int: ...

    def last_move(self) -> bridge.BridgeMove: ...

    def feature(self) -> TensorDict: ...


class BridgeVecEnv:
    def __init__(self):
        ...

    def append(self, env: BridgeEnv): ...

    def reset(self): ...

    def all_terminated(self) -> bool: ...

    def any_terminated(self) -> bool: ...

    def step(self, reply: TensorDict): ...

    def feature(self) -> TensorDict: ...

    def size(self) -> int: ...

    def display(self, num_envs: int): ...


class SuperviseDataGenerator:
    def __init__(self, trajectories: List[List[int]], batch_size: int, game: bridge.BridgeGame, seed: int): ...

    def next_batch(self, device: str) -> TensorDict: ...

    def all_data(self, device: str) -> TensorDict: ...


class Resampler:
    pass


class UniformResampler(Resampler):
    def __init__(self, seed: int):
        ...

    def resample(self) -> List[int]:
        ...

    def reset_with_params(self, params: Dict[str, str]): ...


class SearchResult:
    moves: List[bridge.BridgeMove]
    scores: List[int]


class PlayBot: ...


class CheatBot(PlayBot):
    def __init__(self):
        ...

    def act(self, state: bridge.BridgeState) -> bridge.BridgeMove: ...


class PIMCConfig:
    num_worlds: int
    search_with_one_legal_move: bool


class PIMCBot(PlayBot):
    def __init__(self, resampler: Resampler, cfg: PIMCConfig):
        ...

    def search(self, state: bridge.BridgeState) -> SearchResult:
        ...

    def act(self, state: bridge.BridgeState) -> bridge.BridgeMove: ...


class OutcomeVector:
    game_status: List[int]
    possible_world: List[bool]
    move: bridge.BridgeMove

    def score(self) -> float: ...


class ParetoFront:
    def __init__(self, outcome_vectors: Optional[List[OutcomeVector]]): ...

    def size(self) -> int: ...

    def insert(self, outcome_vector: OutcomeVector) -> bool: ...

    def empty(self) -> bool: ...

    def score(self) -> float: ...

    def best_outcome(self) -> OutcomeVector: ...

    def set_move(self, move: bridge.BridgeMove): ...

    @staticmethod
    def pareto_front_with_one_outcome_vector(possible_worlds: List[bool], fill_value: int) -> ParetoFront: ...

    def serialize(self) -> str: ...

    @staticmethod
    def deserialize(sr_str: str) -> ParetoFront: ...


def pareto_front_min(lhs: ParetoFront, rhs: ParetoFront) -> ParetoFront: ...


def pareto_front_max(lhs: ParetoFront, rhs: ParetoFront) -> ParetoFront: ...


def pareto_front_dominate(lhs: ParetoFront, rhs: ParetoFront) -> bool: ...


class AlphaMuConfig:
    num_max_moves: int
    num_worlds: int
    search_with_one_legal_move: bool
    root_cut: bool
    early_cut: bool


class BridgeStateWithoutHiddenInfo:
    def __init__(self, state: bridge.BridgeState): ...

    def uid_history(self) -> List[int]: ...

    def apply_move(self, move: bridge.BridgeMove): ...

    def legal_moves(self) -> List[bridge.BridgeMove]: ...

    def current_player(self) -> bridge.Player: ...

    def is_terminal(self) -> bool: ...

    def num_declarer_tricks(self) -> int: ...

    def get_contract(self) -> bridge.Contract: ...

    def serialize(self) -> str: ...

    def deserialize(self, sr_str: str, game: bridge.BridgeGame): ...


class TranspositionTable:
    def __init__(self): ...

    def table(self) -> Dict[BridgeStateWithoutHiddenInfo, ParetoFront]: ...

    def serialize(self) -> str: ...

    def deserialize(self, sr_str: str, game: bridge.BridgeGame): ...


class AlphaMuBot(PlayBot):
    def __init__(self, resampler: Resampler, cfg: AlphaMuConfig): ...

    def act(self, state: bridge.BridgeState) -> bridge.BridgeMove: ...

    def search(self, state: bridge.BridgeState) -> ParetoFront: ...

    def set_tt(self, tt: TranspositionTable): ...

    def get_tt(self) -> TranspositionTable: ...


def construct_state_from_deal(deal: List[int], game: bridge.BridgeGame) -> bridge.BridgeState: ...


def construct_state_from_trajectory(trajectory: List[int], game: bridge.BridgeGame) -> bridge.BridgeState: ...


def is_acting_player_declarer_side(state: bridge.BridgeState) -> bool: ...
